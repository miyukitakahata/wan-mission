# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class users(bases.Baseusers):
    """Represents a users record"""

    id: _str
    firebase_uid: _str
    email: _str
    current_plan: Optional[_str] = None
    is_verified: Optional[_bool] = None
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None
    care_settings: Optional[List['models.care_settings']] = None
    message_logs: Optional[List['models.message_logs']] = None
    payment: Optional[List['models.payment']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.usersKeys']] = None,
        exclude: Optional[Iterable['types.usersKeys']] = None,
        required: Optional[Iterable['types.usersKeys']] = None,
        optional: Optional[Iterable['types.usersKeys']] = None,
        relations: Optional[Mapping['types.usersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.usersKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_relational_fields:
                        raise errors.UnknownRelationalFieldError('users', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users',
            }
        )
        _created_partial_types.add(name)


class care_settings(bases.Basecare_settings):
    """Represents a care_settings record"""

    id: _int
    user_id: _str
    parent_name: Optional[_str] = None
    child_name: Optional[_str] = None
    dog_name: Optional[_str] = None
    care_start_date: Optional[datetime.datetime] = None
    care_end_date: Optional[datetime.datetime] = None
    morning_meal_time: Optional[datetime.datetime] = None
    night_meal_time: Optional[datetime.datetime] = None
    walk_time: Optional[datetime.datetime] = None
    care_password: Optional[_str] = None
    care_clear_status: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None
    care_logs: Optional[List['models.care_logs']] = None
    user: Optional['models.users'] = None
    reflection_notes: Optional[List['models.reflection_notes']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.care_settingsKeys']] = None,
        exclude: Optional[Iterable['types.care_settingsKeys']] = None,
        required: Optional[Iterable['types.care_settingsKeys']] = None,
        optional: Optional[Iterable['types.care_settingsKeys']] = None,
        relations: Optional[Mapping['types.care_settingsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.care_settingsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _care_settings_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _care_settings_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _care_settings_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _care_settings_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _care_settings_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _care_settings_relational_fields:
                        raise errors.UnknownRelationalFieldError('care_settings', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid care_settings / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'care_settings',
            }
        )
        _created_partial_types.add(name)


class care_logs(bases.Basecare_logs):
    """Represents a care_logs record"""

    id: _int
    care_setting_id: _int
    date: Optional[datetime.datetime] = None
    fed_morning: Optional[_bool] = None
    fed_night: Optional[_bool] = None
    created_at: Optional[datetime.datetime] = None
    care_setting: Optional['models.care_settings'] = None
    walk_missions: Optional[List['models.walk_missions']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.care_logsKeys']] = None,
        exclude: Optional[Iterable['types.care_logsKeys']] = None,
        required: Optional[Iterable['types.care_logsKeys']] = None,
        optional: Optional[Iterable['types.care_logsKeys']] = None,
        relations: Optional[Mapping['types.care_logsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.care_logsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _care_logs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _care_logs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _care_logs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _care_logs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _care_logs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _care_logs_relational_fields:
                        raise errors.UnknownRelationalFieldError('care_logs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid care_logs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'care_logs',
            }
        )
        _created_partial_types.add(name)


class reflection_notes(bases.Basereflection_notes):
    """Represents a reflection_notes record"""

    id: _int
    care_setting_id: _int
    content: Optional[_str] = None
    approved_by_parent: _bool
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None
    care_setting: Optional['models.care_settings'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.reflection_notesKeys']] = None,
        exclude: Optional[Iterable['types.reflection_notesKeys']] = None,
        required: Optional[Iterable['types.reflection_notesKeys']] = None,
        optional: Optional[Iterable['types.reflection_notesKeys']] = None,
        relations: Optional[Mapping['types.reflection_notesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.reflection_notesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _reflection_notes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _reflection_notes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _reflection_notes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _reflection_notes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _reflection_notes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _reflection_notes_relational_fields:
                        raise errors.UnknownRelationalFieldError('reflection_notes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid reflection_notes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'reflection_notes',
            }
        )
        _created_partial_types.add(name)


class message_logs(bases.Basemessage_logs):
    """Represents a message_logs record"""

    id: _int
    user_id: _str
    content: Optional[_str] = None
    is_llm_based: Optional[_bool] = None
    created_at: Optional[datetime.datetime] = None
    user: Optional['models.users'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.message_logsKeys']] = None,
        exclude: Optional[Iterable['types.message_logsKeys']] = None,
        required: Optional[Iterable['types.message_logsKeys']] = None,
        optional: Optional[Iterable['types.message_logsKeys']] = None,
        relations: Optional[Mapping['types.message_logsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.message_logsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _message_logs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _message_logs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _message_logs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _message_logs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _message_logs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _message_logs_relational_fields:
                        raise errors.UnknownRelationalFieldError('message_logs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid message_logs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'message_logs',
            }
        )
        _created_partial_types.add(name)


class walk_missions(bases.Basewalk_missions):
    """Represents a walk_missions record"""

    id: _int
    care_log_id: _int
    started_at: Optional[datetime.datetime] = None
    ended_at: Optional[datetime.datetime] = None
    total_distance_m: Optional[_int] = None
    result: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None
    care_log: Optional['models.care_logs'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.walk_missionsKeys']] = None,
        exclude: Optional[Iterable['types.walk_missionsKeys']] = None,
        required: Optional[Iterable['types.walk_missionsKeys']] = None,
        optional: Optional[Iterable['types.walk_missionsKeys']] = None,
        relations: Optional[Mapping['types.walk_missionsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.walk_missionsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _walk_missions_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _walk_missions_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _walk_missions_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _walk_missions_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _walk_missions_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _walk_missions_relational_fields:
                        raise errors.UnknownRelationalFieldError('walk_missions', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid walk_missions / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'walk_missions',
            }
        )
        _created_partial_types.add(name)


class payment(bases.Basepayment):
    """Represents a payment record"""

    id: _int
    user_id: _str
    firebase_uid: Optional[_str] = None
    stripe_session_id: _str
    stripe_payment_intent_id: Optional[_str] = None
    stripe_charge_id: Optional[_str] = None
    amount: Optional[_int] = None
    currency: Optional[_str] = None
    status: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None
    user: Optional['models.users'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.paymentKeys']] = None,
        exclude: Optional[Iterable['types.paymentKeys']] = None,
        required: Optional[Iterable['types.paymentKeys']] = None,
        optional: Optional[Iterable['types.paymentKeys']] = None,
        relations: Optional[Mapping['types.paymentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.paymentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _payment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _payment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _payment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _payment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _payment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _payment_relational_fields:
                        raise errors.UnknownRelationalFieldError('payment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid payment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'payment',
            }
        )
        _created_partial_types.add(name)


class webhook_events(bases.Basewebhook_events):
    """Represents a webhook_events record"""

    id: _str
    event_type: Optional[_str] = None
    stripe_session_id: Optional[_str] = None
    stripe_payment_intent_id: Optional[_str] = None
    customer_email: Optional[_str] = None
    amount: Optional[_int] = None
    currency: Optional[_str] = None
    payment_status: Optional[_str] = None
    payload: Optional['fields.Json'] = None
    received_at: Optional[datetime.datetime] = None
    processed: _bool
    error_message: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.webhook_eventsKeys']] = None,
        exclude: Optional[Iterable['types.webhook_eventsKeys']] = None,
        required: Optional[Iterable['types.webhook_eventsKeys']] = None,
        optional: Optional[Iterable['types.webhook_eventsKeys']] = None,
        relations: Optional[Mapping['types.webhook_eventsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.webhook_eventsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _webhook_events_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _webhook_events_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _webhook_events_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _webhook_events_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "webhook_events" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid webhook_events / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'webhook_events',
            }
        )
        _created_partial_types.add(name)



_users_relational_fields: Set[str] = {
        'care_settings',
        'message_logs',
        'payment',
    }
_users_fields: Dict['types.usersKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firebase_uid', {
            'name': 'firebase_uid',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('current_plan', {
            'name': 'current_plan',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_verified', {
            'name': 'is_verified',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_settings', {
            'name': 'care_settings',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.care_settings\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('message_logs', {
            'name': 'message_logs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.message_logs\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('payment', {
            'name': 'payment',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.payment\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_care_settings_relational_fields: Set[str] = {
        'care_logs',
        'user',
        'reflection_notes',
    }
_care_settings_fields: Dict['types.care_settingsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('parent_name', {
            'name': 'parent_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('child_name', {
            'name': 'child_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dog_name', {
            'name': 'dog_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_start_date', {
            'name': 'care_start_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_end_date', {
            'name': 'care_end_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('morning_meal_time', {
            'name': 'morning_meal_time',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('night_meal_time', {
            'name': 'night_meal_time',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('walk_time', {
            'name': 'walk_time',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_password', {
            'name': 'care_password',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_clear_status', {
            'name': 'care_clear_status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_logs', {
            'name': 'care_logs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.care_logs\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
        ('reflection_notes', {
            'name': 'reflection_notes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.reflection_notes\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_care_logs_relational_fields: Set[str] = {
        'care_setting',
        'walk_missions',
    }
_care_logs_fields: Dict['types.care_logsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_setting_id', {
            'name': 'care_setting_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('fed_morning', {
            'name': 'fed_morning',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('fed_night', {
            'name': 'fed_night',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_setting', {
            'name': 'care_setting',
            'is_list': False,
            'optional': True,
            'type': 'models.care_settings',
            'is_relational': True,
            'documentation': None,
        }),
        ('walk_missions', {
            'name': 'walk_missions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.walk_missions\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_reflection_notes_relational_fields: Set[str] = {
        'care_setting',
    }
_reflection_notes_fields: Dict['types.reflection_notesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_setting_id', {
            'name': 'care_setting_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('approved_by_parent', {
            'name': 'approved_by_parent',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_setting', {
            'name': 'care_setting',
            'is_list': False,
            'optional': True,
            'type': 'models.care_settings',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_message_logs_relational_fields: Set[str] = {
        'user',
    }
_message_logs_fields: Dict['types.message_logsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_llm_based', {
            'name': 'is_llm_based',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_walk_missions_relational_fields: Set[str] = {
        'care_log',
    }
_walk_missions_fields: Dict['types.walk_missionsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_log_id', {
            'name': 'care_log_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('started_at', {
            'name': 'started_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ended_at', {
            'name': 'ended_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('total_distance_m', {
            'name': 'total_distance_m',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('result', {
            'name': 'result',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('care_log', {
            'name': 'care_log',
            'is_list': False,
            'optional': True,
            'type': 'models.care_logs',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_payment_relational_fields: Set[str] = {
        'user',
    }
_payment_fields: Dict['types.paymentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firebase_uid', {
            'name': 'firebase_uid',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripe_session_id', {
            'name': 'stripe_session_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripe_payment_intent_id', {
            'name': 'stripe_payment_intent_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripe_charge_id', {
            'name': 'stripe_charge_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_webhook_events_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_webhook_events_fields: Dict['types.webhook_eventsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('event_type', {
            'name': 'event_type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripe_session_id', {
            'name': 'stripe_session_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stripe_payment_intent_id', {
            'name': 'stripe_payment_intent_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('customer_email', {
            'name': 'customer_email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('payment_status', {
            'name': 'payment_status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('payload', {
            'name': 'payload',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('received_at', {
            'name': 'received_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('processed', {
            'name': 'processed',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('error_message', {
            'name': 'error_message',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(users)
model_rebuild(care_settings)
model_rebuild(care_logs)
model_rebuild(reflection_notes)
model_rebuild(message_logs)
model_rebuild(walk_missions)
model_rebuild(payment)
model_rebuild(webhook_events)
