# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class usersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().query_raw(
            'SELECT * FROM users WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users.prisma().query_first(
            'SELECT * FROM users WHERE firebase_uid = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.usersCreateInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Create a new users record.

        Parameters
        ----------
        data
            users record data
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created users record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users record from just the required fields
        users = await users.prisma().create(
            data={
                # data to create a users record
                'firebase_uid': 'ggciceaie',
                'email': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.usersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users.prisma().create_many(
            data=[
                {
                    # data to create a users record
                    'firebase_uid': 'cadfabfehe',
                    'email': 'dgiiaaijj',
                },
                {
                    # data to create a users record
                    'firebase_uid': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users record.

        Parameters
        ----------
        where
            users filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The deleted users record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users record.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N results
        where
            users filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users]
            The list of all users records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users records
        users = await users.prisma().find_many(take=10)

        # find the first 5 users records ordered by the email field
        users = await users.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the current_plan field
        users = await users.prisma().find_first(
            skip=1,
            order={
                'current_plan': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the is_verified field
        users = await users.prisma().find_first_or_raise(
            skip=1,
            order={
                'is_verified': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.usersUpdateInput,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users record.

        Parameters
        ----------
        data
            users record data specifying what to update
        where
            users filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The updated users record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the users record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.usersWhereUniqueInput,
        data: types.usersUpsertInput,
        include: Optional[types.usersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created or updated users record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'firebase_uid': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
                'update': {
                    'firebase_uid': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.usersUpdateManyMutationInput,
        where: types.usersWhereInput,
    ) -> int:
        """Update multiple users records

        Parameters
        ----------
        data
            users data to update the selected users records to
        where
            Filter to select the users records to update

        Returns
        -------
        int
            The total number of users records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users records
        total = await users.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.usersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> types.usersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.usersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> Union[int, types.usersCountAggregateOutput]:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.usersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.usersWhereInput] = None
    ) -> int:
        """Delete multiple users records.

        Parameters
        ----------
        where
            Optional users filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users records
        total = await users.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.usersScalarFieldKeys'],
        *,
        where: Optional['types.usersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.usersAvgAggregateInput'] = None,
        sum: Optional['types.usersSumAggregateInput'] = None,
        min: Optional['types.usersMinAggregateInput'] = None,
        max: Optional['types.usersMaxAggregateInput'] = None,
        having: Optional['types.usersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.usersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.usersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.usersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.usersGroupByOutput']:
        """Group users records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users fields to group records by
        where
            users filter to select records
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.usersGroupByOutput]
            A list of dictionaries representing the users record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users records by firebase_uid values
        # and count how many records are in each group
        results = await users.prisma().group_by(
            ['firebase_uid'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class care_settingsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.care_settings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await care_settings.prisma().query_raw(
            'SELECT * FROM care_settings WHERE id = $1',
            790425851,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.care_settings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await care_settings.prisma().query_first(
            'SELECT * FROM care_settings WHERE user_id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.care_settingsCreateInput,
        include: Optional[types.care_settingsInclude] = None
    ) -> _PrismaModelT:
        """Create a new care_settings record.

        Parameters
        ----------
        data
            care_settings record data
        include
            Specifies which relations should be loaded on the returned care_settings model

        Returns
        -------
        prisma.models.care_settings
            The created care_settings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a care_settings record from just the required fields
        care_settings = await care_settings.prisma().create(
            data={
                # data to create a care_settings record
                'user_id': 'bbejhfidcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.care_settingsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple care_settings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of care_settings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await care_settings.prisma().create_many(
            data=[
                {
                    # data to create a care_settings record
                    'user_id': 'bgeecijdgg',
                },
                {
                    # data to create a care_settings record
                    'user_id': 'bdiicjafbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.care_settingsWhereUniqueInput,
        include: Optional[types.care_settingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single care_settings record.

        Parameters
        ----------
        where
            care_settings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned care_settings model

        Returns
        -------
        prisma.models.care_settings
            The deleted care_settings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_settings = await care_settings.prisma().delete(
            where={
                'id': 1647418052,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.care_settingsWhereUniqueInput,
        include: Optional[types.care_settingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique care_settings record.

        Parameters
        ----------
        where
            care_settings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned care_settings model

        Returns
        -------
        prisma.models.care_settings
            The found care_settings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_settings = await care_settings.prisma().find_unique(
            where={
                'id': 1675546029,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.care_settingsWhereUniqueInput,
        include: Optional[types.care_settingsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique care_settings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            care_settings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned care_settings model

        Returns
        -------
        prisma.models.care_settings
            The found care_settings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_settings = await care_settings.prisma().find_unique_or_raise(
            where={
                'id': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_settingsWhereInput] = None,
        cursor: Optional[types.care_settingsWhereUniqueInput] = None,
        include: Optional[types.care_settingsInclude] = None,
        order: Optional[Union[types.care_settingsOrderByInput, List[types.care_settingsOrderByInput]]] = None,
        distinct: Optional[List[types.care_settingsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple care_settings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of care_settings records returned
        skip
            Ignore the first N results
        where
            care_settings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned care_settings model
        order
            Order the returned care_settings records by any field
        distinct
            Filter care_settings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.care_settings]
            The list of all care_settings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 care_settings records
        care_settings = await care_settings.prisma().find_many(take=10)

        # find the first 5 care_settings records ordered by the parent_name field
        care_settings = await care_settings.prisma().find_many(
            take=5,
            order={
                'parent_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.care_settingsWhereInput] = None,
        cursor: Optional[types.care_settingsWhereUniqueInput] = None,
        include: Optional[types.care_settingsInclude] = None,
        order: Optional[Union[types.care_settingsOrderByInput, List[types.care_settingsOrderByInput]]] = None,
        distinct: Optional[List[types.care_settingsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single care_settings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            care_settings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned care_settings model
        order
            Order the returned care_settings records by any field
        distinct
            Filter care_settings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.care_settings
            The first care_settings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second care_settings record ordered by the child_name field
        care_settings = await care_settings.prisma().find_first(
            skip=1,
            order={
                'child_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.care_settingsWhereInput] = None,
        cursor: Optional[types.care_settingsWhereUniqueInput] = None,
        include: Optional[types.care_settingsInclude] = None,
        order: Optional[Union[types.care_settingsOrderByInput, List[types.care_settingsOrderByInput]]] = None,
        distinct: Optional[List[types.care_settingsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single care_settings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            care_settings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned care_settings model
        order
            Order the returned care_settings records by any field
        distinct
            Filter care_settings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.care_settings
            The first care_settings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second care_settings record ordered by the dog_name field
        care_settings = await care_settings.prisma().find_first_or_raise(
            skip=1,
            order={
                'dog_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.care_settingsUpdateInput,
        where: types.care_settingsWhereUniqueInput,
        include: Optional[types.care_settingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single care_settings record.

        Parameters
        ----------
        data
            care_settings record data specifying what to update
        where
            care_settings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned care_settings model

        Returns
        -------
        prisma.models.care_settings
            The updated care_settings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        care_settings = await care_settings.prisma().update(
            where={
                'id': 326272115,
            },
            data={
                # data to update the care_settings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.care_settingsWhereUniqueInput,
        data: types.care_settingsUpsertInput,
        include: Optional[types.care_settingsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            care_settings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned care_settings model

        Returns
        -------
        prisma.models.care_settings
            The created or updated care_settings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_settings = await care_settings.prisma().upsert(
            where={
                'id': 1343201072,
            },
            data={
                'create': {
                    'id': 1343201072,
                    'user_id': 'bdiicjafbj',
                },
                'update': {
                    'user_id': 'bdiicjafbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.care_settingsUpdateManyMutationInput,
        where: types.care_settingsWhereInput,
    ) -> int:
        """Update multiple care_settings records

        Parameters
        ----------
        data
            care_settings data to update the selected care_settings records to
        where
            Filter to select the care_settings records to update

        Returns
        -------
        int
            The total number of care_settings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all care_settings records
        total = await care_settings.prisma().update_many(
            data={
                'care_start_date': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_settingsWhereInput] = None,
        cursor: Optional[types.care_settingsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of care_settings records present in the database

        Parameters
        ----------
        select
            Select the care_settings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            care_settings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.care_settingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await care_settings.prisma().count()

        # results: prisma.types.care_settingsCountAggregateOutput
        results = await care_settings.prisma().count(
            select={
                '_all': True,
                'care_end_date': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.care_settingsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_settingsWhereInput] = None,
        cursor: Optional[types.care_settingsWhereUniqueInput] = None,
    ) -> types.care_settingsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.care_settingsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_settingsWhereInput] = None,
        cursor: Optional[types.care_settingsWhereUniqueInput] = None,
    ) -> Union[int, types.care_settingsCountAggregateOutput]:
        """Count the number of care_settings records present in the database

        Parameters
        ----------
        select
            Select the care_settings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            care_settings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.care_settingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await care_settings.prisma().count()

        # results: prisma.types.care_settingsCountAggregateOutput
        results = await care_settings.prisma().count(
            select={
                '_all': True,
                'morning_meal_time': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.care_settingsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.care_settingsWhereInput] = None
    ) -> int:
        """Delete multiple care_settings records.

        Parameters
        ----------
        where
            Optional care_settings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of care_settings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all care_settings records
        total = await care_settings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.care_settingsScalarFieldKeys'],
        *,
        where: Optional['types.care_settingsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.care_settingsAvgAggregateInput'] = None,
        sum: Optional['types.care_settingsSumAggregateInput'] = None,
        min: Optional['types.care_settingsMinAggregateInput'] = None,
        max: Optional['types.care_settingsMaxAggregateInput'] = None,
        having: Optional['types.care_settingsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.care_settingsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.care_settingsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.care_settingsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.care_settingsGroupByOutput']:
        """Group care_settings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar care_settings fields to group records by
        where
            care_settings filter to select records
        take
            Limit the maximum number of care_settings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.care_settingsGroupByOutput]
            A list of dictionaries representing the care_settings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group care_settings records by night_meal_time values
        # and count how many records are in each group
        results = await care_settings.prisma().group_by(
            ['night_meal_time'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class care_logsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.care_logs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await care_logs.prisma().query_raw(
            'SELECT * FROM care_logs WHERE id = $1',
            675780521,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.care_logs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await care_logs.prisma().query_first(
            'SELECT * FROM care_logs WHERE care_setting_id = $1',
            744964398,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.care_logsCreateInput,
        include: Optional[types.care_logsInclude] = None
    ) -> _PrismaModelT:
        """Create a new care_logs record.

        Parameters
        ----------
        data
            care_logs record data
        include
            Specifies which relations should be loaded on the returned care_logs model

        Returns
        -------
        prisma.models.care_logs
            The created care_logs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a care_logs record from just the required fields
        care_logs = await care_logs.prisma().create(
            data={
                # data to create a care_logs record
                'care_setting_id': 1969681615,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.care_logsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple care_logs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of care_logs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await care_logs.prisma().create_many(
            data=[
                {
                    # data to create a care_logs record
                    'care_setting_id': 1116175964,
                },
                {
                    # data to create a care_logs record
                    'care_setting_id': 861472101,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.care_logsWhereUniqueInput,
        include: Optional[types.care_logsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single care_logs record.

        Parameters
        ----------
        where
            care_logs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned care_logs model

        Returns
        -------
        prisma.models.care_logs
            The deleted care_logs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_logs = await care_logs.prisma().delete(
            where={
                'id': 1303003706,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.care_logsWhereUniqueInput,
        include: Optional[types.care_logsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique care_logs record.

        Parameters
        ----------
        where
            care_logs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned care_logs model

        Returns
        -------
        prisma.models.care_logs
            The found care_logs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_logs = await care_logs.prisma().find_unique(
            where={
                'id': 1686638315,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.care_logsWhereUniqueInput,
        include: Optional[types.care_logsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique care_logs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            care_logs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned care_logs model

        Returns
        -------
        prisma.models.care_logs
            The found care_logs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_logs = await care_logs.prisma().find_unique_or_raise(
            where={
                'id': 2000430152,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_logsWhereInput] = None,
        cursor: Optional[types.care_logsWhereUniqueInput] = None,
        include: Optional[types.care_logsInclude] = None,
        order: Optional[Union[types.care_logsOrderByInput, List[types.care_logsOrderByInput]]] = None,
        distinct: Optional[List[types.care_logsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple care_logs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of care_logs records returned
        skip
            Ignore the first N results
        where
            care_logs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned care_logs model
        order
            Order the returned care_logs records by any field
        distinct
            Filter care_logs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.care_logs]
            The list of all care_logs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 care_logs records
        care_logs = await care_logs.prisma().find_many(take=10)

        # find the first 5 care_logs records ordered by the date field
        care_logs = await care_logs.prisma().find_many(
            take=5,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.care_logsWhereInput] = None,
        cursor: Optional[types.care_logsWhereUniqueInput] = None,
        include: Optional[types.care_logsInclude] = None,
        order: Optional[Union[types.care_logsOrderByInput, List[types.care_logsOrderByInput]]] = None,
        distinct: Optional[List[types.care_logsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single care_logs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            care_logs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned care_logs model
        order
            Order the returned care_logs records by any field
        distinct
            Filter care_logs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.care_logs
            The first care_logs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second care_logs record ordered by the fed_morning field
        care_logs = await care_logs.prisma().find_first(
            skip=1,
            order={
                'fed_morning': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.care_logsWhereInput] = None,
        cursor: Optional[types.care_logsWhereUniqueInput] = None,
        include: Optional[types.care_logsInclude] = None,
        order: Optional[Union[types.care_logsOrderByInput, List[types.care_logsOrderByInput]]] = None,
        distinct: Optional[List[types.care_logsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single care_logs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            care_logs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned care_logs model
        order
            Order the returned care_logs records by any field
        distinct
            Filter care_logs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.care_logs
            The first care_logs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second care_logs record ordered by the fed_night field
        care_logs = await care_logs.prisma().find_first_or_raise(
            skip=1,
            order={
                'fed_night': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.care_logsUpdateInput,
        where: types.care_logsWhereUniqueInput,
        include: Optional[types.care_logsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single care_logs record.

        Parameters
        ----------
        data
            care_logs record data specifying what to update
        where
            care_logs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned care_logs model

        Returns
        -------
        prisma.models.care_logs
            The updated care_logs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        care_logs = await care_logs.prisma().update(
            where={
                'id': 1868141281,
            },
            data={
                # data to update the care_logs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.care_logsWhereUniqueInput,
        data: types.care_logsUpsertInput,
        include: Optional[types.care_logsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            care_logs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned care_logs model

        Returns
        -------
        prisma.models.care_logs
            The created or updated care_logs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        care_logs = await care_logs.prisma().upsert(
            where={
                'id': 1860847622,
            },
            data={
                'create': {
                    'id': 1860847622,
                    'care_setting_id': 861472101,
                },
                'update': {
                    'care_setting_id': 861472101,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.care_logsUpdateManyMutationInput,
        where: types.care_logsWhereInput,
    ) -> int:
        """Update multiple care_logs records

        Parameters
        ----------
        data
            care_logs data to update the selected care_logs records to
        where
            Filter to select the care_logs records to update

        Returns
        -------
        int
            The total number of care_logs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all care_logs records
        total = await care_logs.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_logsWhereInput] = None,
        cursor: Optional[types.care_logsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of care_logs records present in the database

        Parameters
        ----------
        select
            Select the care_logs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            care_logs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.care_logsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await care_logs.prisma().count()

        # results: prisma.types.care_logsCountAggregateOutput
        results = await care_logs.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.care_logsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_logsWhereInput] = None,
        cursor: Optional[types.care_logsWhereUniqueInput] = None,
    ) -> types.care_logsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.care_logsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.care_logsWhereInput] = None,
        cursor: Optional[types.care_logsWhereUniqueInput] = None,
    ) -> Union[int, types.care_logsCountAggregateOutput]:
        """Count the number of care_logs records present in the database

        Parameters
        ----------
        select
            Select the care_logs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            care_logs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.care_logsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await care_logs.prisma().count()

        # results: prisma.types.care_logsCountAggregateOutput
        results = await care_logs.prisma().count(
            select={
                '_all': True,
                'care_setting_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.care_logsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.care_logsWhereInput] = None
    ) -> int:
        """Delete multiple care_logs records.

        Parameters
        ----------
        where
            Optional care_logs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of care_logs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all care_logs records
        total = await care_logs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.care_logsScalarFieldKeys'],
        *,
        where: Optional['types.care_logsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.care_logsAvgAggregateInput'] = None,
        sum: Optional['types.care_logsSumAggregateInput'] = None,
        min: Optional['types.care_logsMinAggregateInput'] = None,
        max: Optional['types.care_logsMaxAggregateInput'] = None,
        having: Optional['types.care_logsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.care_logsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.care_logsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.care_logsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.care_logsGroupByOutput']:
        """Group care_logs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar care_logs fields to group records by
        where
            care_logs filter to select records
        take
            Limit the maximum number of care_logs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.care_logsGroupByOutput]
            A list of dictionaries representing the care_logs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group care_logs records by date values
        # and count how many records are in each group
        results = await care_logs.prisma().group_by(
            ['date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class reflection_notesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.reflection_notes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await reflection_notes.prisma().query_raw(
            'SELECT * FROM reflection_notes WHERE id = $1',
            1448521415,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.reflection_notes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await reflection_notes.prisma().query_first(
            'SELECT * FROM reflection_notes WHERE care_setting_id = $1',
            1628650740,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.reflection_notesCreateInput,
        include: Optional[types.reflection_notesInclude] = None
    ) -> _PrismaModelT:
        """Create a new reflection_notes record.

        Parameters
        ----------
        data
            reflection_notes record data
        include
            Specifies which relations should be loaded on the returned reflection_notes model

        Returns
        -------
        prisma.models.reflection_notes
            The created reflection_notes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a reflection_notes record from just the required fields
        reflection_notes = await reflection_notes.prisma().create(
            data={
                # data to create a reflection_notes record
                'care_setting_id': 1249606685,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.reflection_notesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple reflection_notes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of reflection_notes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await reflection_notes.prisma().create_many(
            data=[
                {
                    # data to create a reflection_notes record
                    'care_setting_id': 835903122,
                },
                {
                    # data to create a reflection_notes record
                    'care_setting_id': 763719779,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.reflection_notesWhereUniqueInput,
        include: Optional[types.reflection_notesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single reflection_notes record.

        Parameters
        ----------
        where
            reflection_notes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned reflection_notes model

        Returns
        -------
        prisma.models.reflection_notes
            The deleted reflection_notes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reflection_notes = await reflection_notes.prisma().delete(
            where={
                'id': 429995104,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.reflection_notesWhereUniqueInput,
        include: Optional[types.reflection_notesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique reflection_notes record.

        Parameters
        ----------
        where
            reflection_notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned reflection_notes model

        Returns
        -------
        prisma.models.reflection_notes
            The found reflection_notes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reflection_notes = await reflection_notes.prisma().find_unique(
            where={
                'id': 1775811865,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.reflection_notesWhereUniqueInput,
        include: Optional[types.reflection_notesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique reflection_notes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            reflection_notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned reflection_notes model

        Returns
        -------
        prisma.models.reflection_notes
            The found reflection_notes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reflection_notes = await reflection_notes.prisma().find_unique_or_raise(
            where={
                'id': 893145566,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reflection_notesWhereInput] = None,
        cursor: Optional[types.reflection_notesWhereUniqueInput] = None,
        include: Optional[types.reflection_notesInclude] = None,
        order: Optional[Union[types.reflection_notesOrderByInput, List[types.reflection_notesOrderByInput]]] = None,
        distinct: Optional[List[types.reflection_notesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple reflection_notes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of reflection_notes records returned
        skip
            Ignore the first N results
        where
            reflection_notes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned reflection_notes model
        order
            Order the returned reflection_notes records by any field
        distinct
            Filter reflection_notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.reflection_notes]
            The list of all reflection_notes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 reflection_notes records
        reflection_notes = await reflection_notes.prisma().find_many(take=10)

        # find the first 5 reflection_notes records ordered by the content field
        reflection_notes = await reflection_notes.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.reflection_notesWhereInput] = None,
        cursor: Optional[types.reflection_notesWhereUniqueInput] = None,
        include: Optional[types.reflection_notesInclude] = None,
        order: Optional[Union[types.reflection_notesOrderByInput, List[types.reflection_notesOrderByInput]]] = None,
        distinct: Optional[List[types.reflection_notesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single reflection_notes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            reflection_notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned reflection_notes model
        order
            Order the returned reflection_notes records by any field
        distinct
            Filter reflection_notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.reflection_notes
            The first reflection_notes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second reflection_notes record ordered by the approved_by_parent field
        reflection_notes = await reflection_notes.prisma().find_first(
            skip=1,
            order={
                'approved_by_parent': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.reflection_notesWhereInput] = None,
        cursor: Optional[types.reflection_notesWhereUniqueInput] = None,
        include: Optional[types.reflection_notesInclude] = None,
        order: Optional[Union[types.reflection_notesOrderByInput, List[types.reflection_notesOrderByInput]]] = None,
        distinct: Optional[List[types.reflection_notesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single reflection_notes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            reflection_notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned reflection_notes model
        order
            Order the returned reflection_notes records by any field
        distinct
            Filter reflection_notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.reflection_notes
            The first reflection_notes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second reflection_notes record ordered by the created_at field
        reflection_notes = await reflection_notes.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.reflection_notesUpdateInput,
        where: types.reflection_notesWhereUniqueInput,
        include: Optional[types.reflection_notesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single reflection_notes record.

        Parameters
        ----------
        data
            reflection_notes record data specifying what to update
        where
            reflection_notes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned reflection_notes model

        Returns
        -------
        prisma.models.reflection_notes
            The updated reflection_notes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        reflection_notes = await reflection_notes.prisma().update(
            where={
                'id': 995405759,
            },
            data={
                # data to update the reflection_notes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.reflection_notesWhereUniqueInput,
        data: types.reflection_notesUpsertInput,
        include: Optional[types.reflection_notesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            reflection_notes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned reflection_notes model

        Returns
        -------
        prisma.models.reflection_notes
            The created or updated reflection_notes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reflection_notes = await reflection_notes.prisma().upsert(
            where={
                'id': 2102736524,
            },
            data={
                'create': {
                    'id': 2102736524,
                    'care_setting_id': 763719779,
                },
                'update': {
                    'care_setting_id': 763719779,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.reflection_notesUpdateManyMutationInput,
        where: types.reflection_notesWhereInput,
    ) -> int:
        """Update multiple reflection_notes records

        Parameters
        ----------
        data
            reflection_notes data to update the selected reflection_notes records to
        where
            Filter to select the reflection_notes records to update

        Returns
        -------
        int
            The total number of reflection_notes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all reflection_notes records
        total = await reflection_notes.prisma().update_many(
            data={
                'updated_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reflection_notesWhereInput] = None,
        cursor: Optional[types.reflection_notesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of reflection_notes records present in the database

        Parameters
        ----------
        select
            Select the reflection_notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            reflection_notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.reflection_notesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await reflection_notes.prisma().count()

        # results: prisma.types.reflection_notesCountAggregateOutput
        results = await reflection_notes.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.reflection_notesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reflection_notesWhereInput] = None,
        cursor: Optional[types.reflection_notesWhereUniqueInput] = None,
    ) -> types.reflection_notesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.reflection_notesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reflection_notesWhereInput] = None,
        cursor: Optional[types.reflection_notesWhereUniqueInput] = None,
    ) -> Union[int, types.reflection_notesCountAggregateOutput]:
        """Count the number of reflection_notes records present in the database

        Parameters
        ----------
        select
            Select the reflection_notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            reflection_notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.reflection_notesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await reflection_notes.prisma().count()

        # results: prisma.types.reflection_notesCountAggregateOutput
        results = await reflection_notes.prisma().count(
            select={
                '_all': True,
                'care_setting_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.reflection_notesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.reflection_notesWhereInput] = None
    ) -> int:
        """Delete multiple reflection_notes records.

        Parameters
        ----------
        where
            Optional reflection_notes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of reflection_notes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all reflection_notes records
        total = await reflection_notes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.reflection_notesScalarFieldKeys'],
        *,
        where: Optional['types.reflection_notesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.reflection_notesAvgAggregateInput'] = None,
        sum: Optional['types.reflection_notesSumAggregateInput'] = None,
        min: Optional['types.reflection_notesMinAggregateInput'] = None,
        max: Optional['types.reflection_notesMaxAggregateInput'] = None,
        having: Optional['types.reflection_notesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.reflection_notesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.reflection_notesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.reflection_notesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.reflection_notesGroupByOutput']:
        """Group reflection_notes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar reflection_notes fields to group records by
        where
            reflection_notes filter to select records
        take
            Limit the maximum number of reflection_notes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.reflection_notesGroupByOutput]
            A list of dictionaries representing the reflection_notes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group reflection_notes records by content values
        # and count how many records are in each group
        results = await reflection_notes.prisma().group_by(
            ['content'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class message_logsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.message_logs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await message_logs.prisma().query_raw(
            'SELECT * FROM message_logs WHERE id = $1',
            271520213,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.message_logs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await message_logs.prisma().query_first(
            'SELECT * FROM message_logs WHERE user_id = $1',
            'efggddide',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.message_logsCreateInput,
        include: Optional[types.message_logsInclude] = None
    ) -> _PrismaModelT:
        """Create a new message_logs record.

        Parameters
        ----------
        data
            message_logs record data
        include
            Specifies which relations should be loaded on the returned message_logs model

        Returns
        -------
        prisma.models.message_logs
            The created message_logs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a message_logs record from just the required fields
        message_logs = await message_logs.prisma().create(
            data={
                # data to create a message_logs record
                'user_id': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.message_logsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple message_logs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of message_logs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await message_logs.prisma().create_many(
            data=[
                {
                    # data to create a message_logs record
                    'user_id': 'bfidgijfjc',
                },
                {
                    # data to create a message_logs record
                    'user_id': 'ihieecagf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.message_logsWhereUniqueInput,
        include: Optional[types.message_logsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single message_logs record.

        Parameters
        ----------
        where
            message_logs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned message_logs model

        Returns
        -------
        prisma.models.message_logs
            The deleted message_logs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message_logs = await message_logs.prisma().delete(
            where={
                'id': 1675280054,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.message_logsWhereUniqueInput,
        include: Optional[types.message_logsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique message_logs record.

        Parameters
        ----------
        where
            message_logs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned message_logs model

        Returns
        -------
        prisma.models.message_logs
            The found message_logs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message_logs = await message_logs.prisma().find_unique(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.message_logsWhereUniqueInput,
        include: Optional[types.message_logsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique message_logs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            message_logs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned message_logs model

        Returns
        -------
        prisma.models.message_logs
            The found message_logs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message_logs = await message_logs.prisma().find_unique_or_raise(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.message_logsWhereInput] = None,
        cursor: Optional[types.message_logsWhereUniqueInput] = None,
        include: Optional[types.message_logsInclude] = None,
        order: Optional[Union[types.message_logsOrderByInput, List[types.message_logsOrderByInput]]] = None,
        distinct: Optional[List[types.message_logsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple message_logs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of message_logs records returned
        skip
            Ignore the first N results
        where
            message_logs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned message_logs model
        order
            Order the returned message_logs records by any field
        distinct
            Filter message_logs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.message_logs]
            The list of all message_logs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 message_logs records
        message_logs = await message_logs.prisma().find_many(take=10)

        # find the first 5 message_logs records ordered by the content field
        message_logs = await message_logs.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.message_logsWhereInput] = None,
        cursor: Optional[types.message_logsWhereUniqueInput] = None,
        include: Optional[types.message_logsInclude] = None,
        order: Optional[Union[types.message_logsOrderByInput, List[types.message_logsOrderByInput]]] = None,
        distinct: Optional[List[types.message_logsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single message_logs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            message_logs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned message_logs model
        order
            Order the returned message_logs records by any field
        distinct
            Filter message_logs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.message_logs
            The first message_logs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second message_logs record ordered by the is_llm_based field
        message_logs = await message_logs.prisma().find_first(
            skip=1,
            order={
                'is_llm_based': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.message_logsWhereInput] = None,
        cursor: Optional[types.message_logsWhereUniqueInput] = None,
        include: Optional[types.message_logsInclude] = None,
        order: Optional[Union[types.message_logsOrderByInput, List[types.message_logsOrderByInput]]] = None,
        distinct: Optional[List[types.message_logsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single message_logs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            message_logs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned message_logs model
        order
            Order the returned message_logs records by any field
        distinct
            Filter message_logs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.message_logs
            The first message_logs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second message_logs record ordered by the created_at field
        message_logs = await message_logs.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.message_logsUpdateInput,
        where: types.message_logsWhereUniqueInput,
        include: Optional[types.message_logsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single message_logs record.

        Parameters
        ----------
        data
            message_logs record data specifying what to update
        where
            message_logs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned message_logs model

        Returns
        -------
        prisma.models.message_logs
            The updated message_logs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message_logs = await message_logs.prisma().update(
            where={
                'id': 60335757,
            },
            data={
                # data to update the message_logs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.message_logsWhereUniqueInput,
        data: types.message_logsUpsertInput,
        include: Optional[types.message_logsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            message_logs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned message_logs model

        Returns
        -------
        prisma.models.message_logs
            The created or updated message_logs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message_logs = await message_logs.prisma().upsert(
            where={
                'id': 684462146,
            },
            data={
                'create': {
                    'id': 684462146,
                    'user_id': 'ihieecagf',
                },
                'update': {
                    'user_id': 'ihieecagf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.message_logsUpdateManyMutationInput,
        where: types.message_logsWhereInput,
    ) -> int:
        """Update multiple message_logs records

        Parameters
        ----------
        data
            message_logs data to update the selected message_logs records to
        where
            Filter to select the message_logs records to update

        Returns
        -------
        int
            The total number of message_logs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all message_logs records
        total = await message_logs.prisma().update_many(
            data={
                'id': 1625503827
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.message_logsWhereInput] = None,
        cursor: Optional[types.message_logsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of message_logs records present in the database

        Parameters
        ----------
        select
            Select the message_logs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            message_logs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.message_logsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await message_logs.prisma().count()

        # results: prisma.types.message_logsCountAggregateOutput
        results = await message_logs.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.message_logsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.message_logsWhereInput] = None,
        cursor: Optional[types.message_logsWhereUniqueInput] = None,
    ) -> types.message_logsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.message_logsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.message_logsWhereInput] = None,
        cursor: Optional[types.message_logsWhereUniqueInput] = None,
    ) -> Union[int, types.message_logsCountAggregateOutput]:
        """Count the number of message_logs records present in the database

        Parameters
        ----------
        select
            Select the message_logs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            message_logs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.message_logsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await message_logs.prisma().count()

        # results: prisma.types.message_logsCountAggregateOutput
        results = await message_logs.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.message_logsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.message_logsWhereInput] = None
    ) -> int:
        """Delete multiple message_logs records.

        Parameters
        ----------
        where
            Optional message_logs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of message_logs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all message_logs records
        total = await message_logs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.message_logsScalarFieldKeys'],
        *,
        where: Optional['types.message_logsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.message_logsAvgAggregateInput'] = None,
        sum: Optional['types.message_logsSumAggregateInput'] = None,
        min: Optional['types.message_logsMinAggregateInput'] = None,
        max: Optional['types.message_logsMaxAggregateInput'] = None,
        having: Optional['types.message_logsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.message_logsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.message_logsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.message_logsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.message_logsGroupByOutput']:
        """Group message_logs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar message_logs fields to group records by
        where
            message_logs filter to select records
        take
            Limit the maximum number of message_logs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.message_logsGroupByOutput]
            A list of dictionaries representing the message_logs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group message_logs records by is_llm_based values
        # and count how many records are in each group
        results = await message_logs.prisma().group_by(
            ['is_llm_based'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class walk_missionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.walk_missions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await walk_missions.prisma().query_raw(
            'SELECT * FROM walk_missions WHERE id = $1',
            521827728,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.walk_missions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await walk_missions.prisma().query_first(
            'SELECT * FROM walk_missions WHERE care_log_id = $1',
            1266032265,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.walk_missionsCreateInput,
        include: Optional[types.walk_missionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new walk_missions record.

        Parameters
        ----------
        data
            walk_missions record data
        include
            Specifies which relations should be loaded on the returned walk_missions model

        Returns
        -------
        prisma.models.walk_missions
            The created walk_missions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a walk_missions record from just the required fields
        walk_missions = await walk_missions.prisma().create(
            data={
                # data to create a walk_missions record
                'care_log_id': 93253262,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.walk_missionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple walk_missions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of walk_missions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await walk_missions.prisma().create_many(
            data=[
                {
                    # data to create a walk_missions record
                    'care_log_id': 2053047983,
                },
                {
                    # data to create a walk_missions record
                    'care_log_id': 685333180,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.walk_missionsWhereUniqueInput,
        include: Optional[types.walk_missionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single walk_missions record.

        Parameters
        ----------
        where
            walk_missions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned walk_missions model

        Returns
        -------
        prisma.models.walk_missions
            The deleted walk_missions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        walk_missions = await walk_missions.prisma().delete(
            where={
                'id': 127474245,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.walk_missionsWhereUniqueInput,
        include: Optional[types.walk_missionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique walk_missions record.

        Parameters
        ----------
        where
            walk_missions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned walk_missions model

        Returns
        -------
        prisma.models.walk_missions
            The found walk_missions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        walk_missions = await walk_missions.prisma().find_unique(
            where={
                'id': 948921754,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.walk_missionsWhereUniqueInput,
        include: Optional[types.walk_missionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique walk_missions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            walk_missions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned walk_missions model

        Returns
        -------
        prisma.models.walk_missions
            The found walk_missions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        walk_missions = await walk_missions.prisma().find_unique_or_raise(
            where={
                'id': 1964990155,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.walk_missionsWhereInput] = None,
        cursor: Optional[types.walk_missionsWhereUniqueInput] = None,
        include: Optional[types.walk_missionsInclude] = None,
        order: Optional[Union[types.walk_missionsOrderByInput, List[types.walk_missionsOrderByInput]]] = None,
        distinct: Optional[List[types.walk_missionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple walk_missions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of walk_missions records returned
        skip
            Ignore the first N results
        where
            walk_missions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned walk_missions model
        order
            Order the returned walk_missions records by any field
        distinct
            Filter walk_missions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.walk_missions]
            The list of all walk_missions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 walk_missions records
        walk_missions = await walk_missions.prisma().find_many(take=10)

        # find the first 5 walk_missions records ordered by the started_at field
        walk_missions = await walk_missions.prisma().find_many(
            take=5,
            order={
                'started_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.walk_missionsWhereInput] = None,
        cursor: Optional[types.walk_missionsWhereUniqueInput] = None,
        include: Optional[types.walk_missionsInclude] = None,
        order: Optional[Union[types.walk_missionsOrderByInput, List[types.walk_missionsOrderByInput]]] = None,
        distinct: Optional[List[types.walk_missionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single walk_missions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            walk_missions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned walk_missions model
        order
            Order the returned walk_missions records by any field
        distinct
            Filter walk_missions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.walk_missions
            The first walk_missions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second walk_missions record ordered by the ended_at field
        walk_missions = await walk_missions.prisma().find_first(
            skip=1,
            order={
                'ended_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.walk_missionsWhereInput] = None,
        cursor: Optional[types.walk_missionsWhereUniqueInput] = None,
        include: Optional[types.walk_missionsInclude] = None,
        order: Optional[Union[types.walk_missionsOrderByInput, List[types.walk_missionsOrderByInput]]] = None,
        distinct: Optional[List[types.walk_missionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single walk_missions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            walk_missions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned walk_missions model
        order
            Order the returned walk_missions records by any field
        distinct
            Filter walk_missions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.walk_missions
            The first walk_missions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second walk_missions record ordered by the total_distance_m field
        walk_missions = await walk_missions.prisma().find_first_or_raise(
            skip=1,
            order={
                'total_distance_m': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.walk_missionsUpdateInput,
        where: types.walk_missionsWhereUniqueInput,
        include: Optional[types.walk_missionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single walk_missions record.

        Parameters
        ----------
        data
            walk_missions record data specifying what to update
        where
            walk_missions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned walk_missions model

        Returns
        -------
        prisma.models.walk_missions
            The updated walk_missions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        walk_missions = await walk_missions.prisma().update(
            where={
                'id': 1228891816,
            },
            data={
                # data to update the walk_missions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.walk_missionsWhereUniqueInput,
        data: types.walk_missionsUpsertInput,
        include: Optional[types.walk_missionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            walk_missions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned walk_missions model

        Returns
        -------
        prisma.models.walk_missions
            The created or updated walk_missions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        walk_missions = await walk_missions.prisma().upsert(
            where={
                'id': 255202753,
            },
            data={
                'create': {
                    'id': 255202753,
                    'care_log_id': 685333180,
                },
                'update': {
                    'care_log_id': 685333180,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.walk_missionsUpdateManyMutationInput,
        where: types.walk_missionsWhereInput,
    ) -> int:
        """Update multiple walk_missions records

        Parameters
        ----------
        data
            walk_missions data to update the selected walk_missions records to
        where
            Filter to select the walk_missions records to update

        Returns
        -------
        int
            The total number of walk_missions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all walk_missions records
        total = await walk_missions.prisma().update_many(
            data={
                'result': 'bccdfhdigc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.walk_missionsWhereInput] = None,
        cursor: Optional[types.walk_missionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of walk_missions records present in the database

        Parameters
        ----------
        select
            Select the walk_missions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            walk_missions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.walk_missionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await walk_missions.prisma().count()

        # results: prisma.types.walk_missionsCountAggregateOutput
        results = await walk_missions.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.walk_missionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.walk_missionsWhereInput] = None,
        cursor: Optional[types.walk_missionsWhereUniqueInput] = None,
    ) -> types.walk_missionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.walk_missionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.walk_missionsWhereInput] = None,
        cursor: Optional[types.walk_missionsWhereUniqueInput] = None,
    ) -> Union[int, types.walk_missionsCountAggregateOutput]:
        """Count the number of walk_missions records present in the database

        Parameters
        ----------
        select
            Select the walk_missions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            walk_missions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.walk_missionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await walk_missions.prisma().count()

        # results: prisma.types.walk_missionsCountAggregateOutput
        results = await walk_missions.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.walk_missionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.walk_missionsWhereInput] = None
    ) -> int:
        """Delete multiple walk_missions records.

        Parameters
        ----------
        where
            Optional walk_missions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of walk_missions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all walk_missions records
        total = await walk_missions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.walk_missionsScalarFieldKeys'],
        *,
        where: Optional['types.walk_missionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.walk_missionsAvgAggregateInput'] = None,
        sum: Optional['types.walk_missionsSumAggregateInput'] = None,
        min: Optional['types.walk_missionsMinAggregateInput'] = None,
        max: Optional['types.walk_missionsMaxAggregateInput'] = None,
        having: Optional['types.walk_missionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.walk_missionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.walk_missionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.walk_missionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.walk_missionsGroupByOutput']:
        """Group walk_missions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar walk_missions fields to group records by
        where
            walk_missions filter to select records
        take
            Limit the maximum number of walk_missions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.walk_missionsGroupByOutput]
            A list of dictionaries representing the walk_missions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group walk_missions records by care_log_id values
        # and count how many records are in each group
        results = await walk_missions.prisma().group_by(
            ['care_log_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class paymentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.payment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await payment.prisma().query_raw(
            'SELECT * FROM payment WHERE id = $1',
            541269159,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.payment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await payment.prisma().query_first(
            'SELECT * FROM payment WHERE user_id = $1',
            'bageiegghg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.paymentCreateInput,
        include: Optional[types.paymentInclude] = None
    ) -> _PrismaModelT:
        """Create a new payment record.

        Parameters
        ----------
        data
            payment record data
        include
            Specifies which relations should be loaded on the returned payment model

        Returns
        -------
        prisma.models.payment
            The created payment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a payment record from just the required fields
        payment = await payment.prisma().create(
            data={
                # data to create a payment record
                'user_id': 'faidicegb',
                'stripe_session_id': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.paymentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple payment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of payment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await payment.prisma().create_many(
            data=[
                {
                    # data to create a payment record
                    'user_id': 'ihcahiead',
                    'stripe_session_id': 'biheheiajg',
                },
                {
                    # data to create a payment record
                    'user_id': 'jbgijghgb',
                    'stripe_session_id': 'hgjcghfbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.paymentWhereUniqueInput,
        include: Optional[types.paymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single payment record.

        Parameters
        ----------
        where
            payment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned payment model

        Returns
        -------
        prisma.models.payment
            The deleted payment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await payment.prisma().delete(
            where={
                'id': 820312479,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.paymentWhereUniqueInput,
        include: Optional[types.paymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique payment record.

        Parameters
        ----------
        where
            payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned payment model

        Returns
        -------
        prisma.models.payment
            The found payment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await payment.prisma().find_unique(
            where={
                'id': 92728044,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.paymentWhereUniqueInput,
        include: Optional[types.paymentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique payment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned payment model

        Returns
        -------
        prisma.models.payment
            The found payment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await payment.prisma().find_unique_or_raise(
            where={
                'id': 344858293,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.paymentWhereInput] = None,
        cursor: Optional[types.paymentWhereUniqueInput] = None,
        include: Optional[types.paymentInclude] = None,
        order: Optional[Union[types.paymentOrderByInput, List[types.paymentOrderByInput]]] = None,
        distinct: Optional[List[types.paymentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple payment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of payment records returned
        skip
            Ignore the first N results
        where
            payment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned payment model
        order
            Order the returned payment records by any field
        distinct
            Filter payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.payment]
            The list of all payment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 payment records
        payments = await payment.prisma().find_many(take=10)

        # find the first 5 payment records ordered by the firebase_uid field
        payments = await payment.prisma().find_many(
            take=5,
            order={
                'firebase_uid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.paymentWhereInput] = None,
        cursor: Optional[types.paymentWhereUniqueInput] = None,
        include: Optional[types.paymentInclude] = None,
        order: Optional[Union[types.paymentOrderByInput, List[types.paymentOrderByInput]]] = None,
        distinct: Optional[List[types.paymentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single payment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned payment model
        order
            Order the returned payment records by any field
        distinct
            Filter payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.payment
            The first payment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second payment record ordered by the stripe_session_id field
        payment = await payment.prisma().find_first(
            skip=1,
            order={
                'stripe_session_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.paymentWhereInput] = None,
        cursor: Optional[types.paymentWhereUniqueInput] = None,
        include: Optional[types.paymentInclude] = None,
        order: Optional[Union[types.paymentOrderByInput, List[types.paymentOrderByInput]]] = None,
        distinct: Optional[List[types.paymentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single payment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned payment model
        order
            Order the returned payment records by any field
        distinct
            Filter payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.payment
            The first payment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second payment record ordered by the stripe_payment_intent_id field
        payment = await payment.prisma().find_first_or_raise(
            skip=1,
            order={
                'stripe_payment_intent_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.paymentUpdateInput,
        where: types.paymentWhereUniqueInput,
        include: Optional[types.paymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single payment record.

        Parameters
        ----------
        data
            payment record data specifying what to update
        where
            payment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned payment model

        Returns
        -------
        prisma.models.payment
            The updated payment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        payment = await payment.prisma().update(
            where={
                'id': 1121741130,
            },
            data={
                # data to update the payment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.paymentWhereUniqueInput,
        data: types.paymentUpsertInput,
        include: Optional[types.paymentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            payment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned payment model

        Returns
        -------
        prisma.models.payment
            The created or updated payment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await payment.prisma().upsert(
            where={
                'id': 1495896251,
            },
            data={
                'create': {
                    'id': 1495896251,
                    'user_id': 'jbgijghgb',
                    'stripe_session_id': 'hgjcghfbi',
                },
                'update': {
                    'user_id': 'jbgijghgb',
                    'stripe_session_id': 'hgjcghfbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.paymentUpdateManyMutationInput,
        where: types.paymentWhereInput,
    ) -> int:
        """Update multiple payment records

        Parameters
        ----------
        data
            payment data to update the selected payment records to
        where
            Filter to select the payment records to update

        Returns
        -------
        int
            The total number of payment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all payment records
        total = await payment.prisma().update_many(
            data={
                'stripe_charge_id': 'caifcbgii'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.paymentWhereInput] = None,
        cursor: Optional[types.paymentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of payment records present in the database

        Parameters
        ----------
        select
            Select the payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.paymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await payment.prisma().count()

        # results: prisma.types.paymentCountAggregateOutput
        results = await payment.prisma().count(
            select={
                '_all': True,
                'amount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.paymentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.paymentWhereInput] = None,
        cursor: Optional[types.paymentWhereUniqueInput] = None,
    ) -> types.paymentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.paymentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.paymentWhereInput] = None,
        cursor: Optional[types.paymentWhereUniqueInput] = None,
    ) -> Union[int, types.paymentCountAggregateOutput]:
        """Count the number of payment records present in the database

        Parameters
        ----------
        select
            Select the payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.paymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await payment.prisma().count()

        # results: prisma.types.paymentCountAggregateOutput
        results = await payment.prisma().count(
            select={
                '_all': True,
                'currency': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.paymentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.paymentWhereInput] = None
    ) -> int:
        """Delete multiple payment records.

        Parameters
        ----------
        where
            Optional payment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of payment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all payment records
        total = await payment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.paymentScalarFieldKeys'],
        *,
        where: Optional['types.paymentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.paymentAvgAggregateInput'] = None,
        sum: Optional['types.paymentSumAggregateInput'] = None,
        min: Optional['types.paymentMinAggregateInput'] = None,
        max: Optional['types.paymentMaxAggregateInput'] = None,
        having: Optional['types.paymentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.paymentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.paymentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.paymentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.paymentGroupByOutput']:
        """Group payment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar payment fields to group records by
        where
            payment filter to select records
        take
            Limit the maximum number of payment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.paymentGroupByOutput]
            A list of dictionaries representing the payment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group payment records by status values
        # and count how many records are in each group
        results = await payment.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class webhook_eventsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.webhook_events]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await webhook_events.prisma().query_raw(
            'SELECT * FROM webhook_events WHERE id = $1',
            'igaibbfgj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.webhook_events
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await webhook_events.prisma().query_first(
            'SELECT * FROM webhook_events WHERE event_type = $1',
            'bggajdcbbi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.webhook_eventsCreateInput,
        include: Optional[types.webhook_eventsInclude] = None
    ) -> _PrismaModelT:
        """Create a new webhook_events record.

        Parameters
        ----------
        data
            webhook_events record data
        include
            Specifies which relations should be loaded on the returned webhook_events model

        Returns
        -------
        prisma.models.webhook_events
            The created webhook_events record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a webhook_events record from just the required fields
        webhook_events = await webhook_events.prisma().create(
            data={
                # data to create a webhook_events record
                'id': 'fcfhgbjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.webhook_eventsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple webhook_events records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of webhook_events record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await webhook_events.prisma().create_many(
            data=[
                {
                    # data to create a webhook_events record
                    'id': 'hdgcajhjg',
                },
                {
                    # data to create a webhook_events record
                    'id': 'ejdjahicb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.webhook_eventsWhereUniqueInput,
        include: Optional[types.webhook_eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single webhook_events record.

        Parameters
        ----------
        where
            webhook_events filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned webhook_events model

        Returns
        -------
        prisma.models.webhook_events
            The deleted webhook_events record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        webhook_events = await webhook_events.prisma().delete(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.webhook_eventsWhereUniqueInput,
        include: Optional[types.webhook_eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique webhook_events record.

        Parameters
        ----------
        where
            webhook_events filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned webhook_events model

        Returns
        -------
        prisma.models.webhook_events
            The found webhook_events record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        webhook_events = await webhook_events.prisma().find_unique(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.webhook_eventsWhereUniqueInput,
        include: Optional[types.webhook_eventsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique webhook_events record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            webhook_events filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned webhook_events model

        Returns
        -------
        prisma.models.webhook_events
            The found webhook_events record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        webhook_events = await webhook_events.prisma().find_unique_or_raise(
            where={
                'id': 'bjafcgbffc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.webhook_eventsWhereInput] = None,
        cursor: Optional[types.webhook_eventsWhereUniqueInput] = None,
        include: Optional[types.webhook_eventsInclude] = None,
        order: Optional[Union[types.webhook_eventsOrderByInput, List[types.webhook_eventsOrderByInput]]] = None,
        distinct: Optional[List[types.webhook_eventsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple webhook_events records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of webhook_events records returned
        skip
            Ignore the first N results
        where
            webhook_events filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned webhook_events model
        order
            Order the returned webhook_events records by any field
        distinct
            Filter webhook_events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.webhook_events]
            The list of all webhook_events records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 webhook_events records
        webhook_events = await webhook_events.prisma().find_many(take=10)

        # find the first 5 webhook_events records ordered by the stripe_session_id field
        webhook_events = await webhook_events.prisma().find_many(
            take=5,
            order={
                'stripe_session_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.webhook_eventsWhereInput] = None,
        cursor: Optional[types.webhook_eventsWhereUniqueInput] = None,
        include: Optional[types.webhook_eventsInclude] = None,
        order: Optional[Union[types.webhook_eventsOrderByInput, List[types.webhook_eventsOrderByInput]]] = None,
        distinct: Optional[List[types.webhook_eventsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single webhook_events record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            webhook_events filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned webhook_events model
        order
            Order the returned webhook_events records by any field
        distinct
            Filter webhook_events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.webhook_events
            The first webhook_events record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second webhook_events record ordered by the stripe_payment_intent_id field
        webhook_events = await webhook_events.prisma().find_first(
            skip=1,
            order={
                'stripe_payment_intent_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.webhook_eventsWhereInput] = None,
        cursor: Optional[types.webhook_eventsWhereUniqueInput] = None,
        include: Optional[types.webhook_eventsInclude] = None,
        order: Optional[Union[types.webhook_eventsOrderByInput, List[types.webhook_eventsOrderByInput]]] = None,
        distinct: Optional[List[types.webhook_eventsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single webhook_events record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            webhook_events filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned webhook_events model
        order
            Order the returned webhook_events records by any field
        distinct
            Filter webhook_events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.webhook_events
            The first webhook_events record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second webhook_events record ordered by the customer_email field
        webhook_events = await webhook_events.prisma().find_first_or_raise(
            skip=1,
            order={
                'customer_email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.webhook_eventsUpdateInput,
        where: types.webhook_eventsWhereUniqueInput,
        include: Optional[types.webhook_eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single webhook_events record.

        Parameters
        ----------
        data
            webhook_events record data specifying what to update
        where
            webhook_events filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned webhook_events model

        Returns
        -------
        prisma.models.webhook_events
            The updated webhook_events record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        webhook_events = await webhook_events.prisma().update(
            where={
                'id': 'hihegjif',
            },
            data={
                # data to update the webhook_events record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.webhook_eventsWhereUniqueInput,
        data: types.webhook_eventsUpsertInput,
        include: Optional[types.webhook_eventsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            webhook_events filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned webhook_events model

        Returns
        -------
        prisma.models.webhook_events
            The created or updated webhook_events record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        webhook_events = await webhook_events.prisma().upsert(
            where={
                'id': 'bdjidcidac',
            },
            data={
                'create': {
                    'id': 'bdjidcidac',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.webhook_eventsUpdateManyMutationInput,
        where: types.webhook_eventsWhereInput,
    ) -> int:
        """Update multiple webhook_events records

        Parameters
        ----------
        data
            webhook_events data to update the selected webhook_events records to
        where
            Filter to select the webhook_events records to update

        Returns
        -------
        int
            The total number of webhook_events records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all webhook_events records
        total = await webhook_events.prisma().update_many(
            data={
                'amount': 856000655
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.webhook_eventsWhereInput] = None,
        cursor: Optional[types.webhook_eventsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of webhook_events records present in the database

        Parameters
        ----------
        select
            Select the webhook_events fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            webhook_events filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.webhook_eventsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await webhook_events.prisma().count()

        # results: prisma.types.webhook_eventsCountAggregateOutput
        results = await webhook_events.prisma().count(
            select={
                '_all': True,
                'currency': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.webhook_eventsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.webhook_eventsWhereInput] = None,
        cursor: Optional[types.webhook_eventsWhereUniqueInput] = None,
    ) -> types.webhook_eventsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.webhook_eventsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.webhook_eventsWhereInput] = None,
        cursor: Optional[types.webhook_eventsWhereUniqueInput] = None,
    ) -> Union[int, types.webhook_eventsCountAggregateOutput]:
        """Count the number of webhook_events records present in the database

        Parameters
        ----------
        select
            Select the webhook_events fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            webhook_events filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.webhook_eventsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await webhook_events.prisma().count()

        # results: prisma.types.webhook_eventsCountAggregateOutput
        results = await webhook_events.prisma().count(
            select={
                '_all': True,
                'payment_status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.webhook_eventsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.webhook_eventsWhereInput] = None
    ) -> int:
        """Delete multiple webhook_events records.

        Parameters
        ----------
        where
            Optional webhook_events filter to find the records to be deleted

        Returns
        -------
        int
            The total number of webhook_events records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all webhook_events records
        total = await webhook_events.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.webhook_eventsScalarFieldKeys'],
        *,
        where: Optional['types.webhook_eventsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.webhook_eventsAvgAggregateInput'] = None,
        sum: Optional['types.webhook_eventsSumAggregateInput'] = None,
        min: Optional['types.webhook_eventsMinAggregateInput'] = None,
        max: Optional['types.webhook_eventsMaxAggregateInput'] = None,
        having: Optional['types.webhook_eventsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.webhook_eventsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.webhook_eventsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.webhook_eventsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.webhook_eventsGroupByOutput']:
        """Group webhook_events records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar webhook_events fields to group records by
        where
            webhook_events filter to select records
        take
            Limit the maximum number of webhook_events records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.webhook_eventsGroupByOutput]
            A list of dictionaries representing the webhook_events record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group webhook_events records by payload values
        # and count how many records are in each group
        results = await webhook_events.prisma().group_by(
            ['payload'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models